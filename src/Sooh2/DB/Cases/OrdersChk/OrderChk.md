# 消息发送控制器

## 1.设计目标

1. 用于两个子系统（比如：交易系统和资金余额账户系统）之间订单比对
2. 顺带支持余额比对


注意：

1. 这里不锁表，所以第一轮检查后，会把错误的用户再检查一遍，排除对账当时用户正在操作的情况，但只做一次复查，所以存在用户连续踩雷的可能性
2. 设计上，不考虑删除订单的情况，请以增加方式补上相关记录后（或手动删除对账系统内订单表的记录），再次运行程序检查
3. 一天最多只有一个检查批次（可以多次执行检查，但批次只有一个），并且一旦确认，当日的不能再查
4. 针对对账的部分，为简化设计，只有一个订单类型字段，因此使用上订单类型字段取值建议为：购买定期，购买活期；而不要只是购买
5. 因不是所有的系统都能准确记录还原每次对账时的场景，所以设计上，对账以当前状态为准（即当前最新的订单和余额）,这会造成:

* 只能确认最后一个批次
* 如果中途有几天没确认，之前的对账批次状态结果几乎就没有意义了
* 确认后，之前的批次（即使数据库记录的状态是未确认），再次确认了

6. 没想出好办法应对多系统时间不同步情况（比如对账是03:00:00, 对完帐以后，又有一笔订单记录的时间是02:59:59, 这笔订单次日对账对余额会丢），
针对这种情况，修复需要手都把丢的单子补到对账订单表，系统上级上，建议：

* 要么系统设置暂停服务器时间，停服期间做对账
* 要么系统提供对账镜像数据库


## 2.使用方式

1. 派生4个子类（用于指定库表）：AccountLastOk,AccountMirror,BatchRecord,Orders

2. 派生 UserOrdersRet 的子类
 
    setDBOfOnline() 记住线上数据库链接，用于获取线上用户余额
    chkUserOrders() 调用父类方法后，追加检查用户余额 $this->_balance = array(balance=>计算出的余额， frose=>计算出的冻结金额)
    getAccMirrorByUid()  获取Mirror实例
    getAccLastokByUid()  获取Lastok实例
    chkUserOrders_balanceChg() 根据订单统计结果，计算余额变化

3. 派生Task类

    此处建议分成两个文件，一个类里都是负责导入订单的方法函数，另一个是遵循要求完成导入和检查

    导入数据部分：根据具体情况，调用Order实例的ensureOrder?() 方法 

    step_prepare_batch() 准备好batch的两个实例（当前的批次和最后成功确认的批次）
    step_prepare() 准备好其他实际使用的类的实例（accMirror、accLastOk，Order，ret）
    step_importOrders() 第一轮，按时间为条件，导入订单
    step_recheckUsers() 第二轮，加入用户限制条件，导入订单

4. 扩展

    当出现负载问题时，按用户分服务器处理，一台服务器负责导入和检查一部分用户的数据（一个用户的数据都在一台服务器上，处理下导入部分即可，然后最后的报表统计和审核确认需要注意下，别忘了kvobj支持分表分库）



## 3 补充说明

### 3.1 依赖 

- \Sooh2\Misc\Loger
- \Sooh2\DB\KVObj
- \Sooh2\Misc\Ini 

### 3.2 重点系统类&常量 

| 类名              | 说明
| ----------------  | ---------------------------------------------------------
| AccountLastOk类   | 审核确认后的用户数据（主要用于记住用户上次对帐最后一笔订单的时间，以及当时的余额情况）
| AccountMirror类   | 当前对账流程中，用户的报错情况和余额情况
| BatchRecord类     | 对账批次的情况（日期做为批次作为主键）：是否已审核确认，对账人数，错误情况
| OrderStatus类     | 订单状态，导入时，所有的订单状态都必须转换成这里定义的几种，后面好统计比对和计算金额变化
| Orders类          | 订单主类，主要是增加了导入函数和状态金额比对方法
| Task类            | 对账主类，对账逻辑的实现框架，需要派生，实现诸如导入等等函数
| UserOrderRet类    | 用户对账结果封装类，主要记录处理用户对账结果，需要派生，实现计算金额变化等函数


### 3.3 重点函数&变量说明 

- Task子类的step_importOrders和step_recheckUsers里面，定义导入订单的函数的时候，多支持一个参数：uid，据此决定是左右订单还是只限指定用户的
- UserOrderRet子类的chkUserOrders_balanceChg返回的是变化值，系统会把之前确认的余额加上返回的变化值做为本次的终值
- UserOrderRet子类的chkUserOrders在调用父类的chkUserOrders后，可以比对一下当前的余额



### 3.4 默认提供的类需要的相关配置 sql

参看几个类的Install静态方法

























## 用途===============================================================================



## 实现逻辑简要介绍

1. 准备运行环境，清理需要清理的数据
2. 找出订单入库(orders类对应的表)
3. 根据用户分组，检查每个用户的订单状态（比对状态、金额）
4. 对每个用户：计算余额变更，读出上次确认的结果，算出本次验证后用户的余额
5. 找出错误的用户，重试2-4步一次，再验证一次，确保处理掉因未锁定导致的处理不到的进行中订单
6. 给出对账结果
7. 管理后台展示结果，并提供审核确认操作

