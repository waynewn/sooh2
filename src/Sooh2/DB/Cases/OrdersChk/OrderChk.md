## 用途

用于两个子系统（比如：交易系统和资金余额账户系统）之间订单比对，顺带支持余额比对

## 实现逻辑简要介绍

1. 准备运行环境，清理需要清理的数据
2. 找出订单入库(orders类对应的表)
3. 根据用户分组，检查每个用户的订单状态（比对状态、金额）
4. 对每个用户：计算余额变更，读出上次确认的结果，算出本次验证后用户的余额
5. 找出错误的用户，重试2-4步一次，再验证一次，确保处理掉因未锁定导致的处理不到的进行中订单
6. 给出对账结果
7. 管理后台展示结果，并提供审核确认操作

## 主要的类

* AccountLastOk   审核确认后的用户数据（主要用于记住用户上次对帐最后一笔订单的时间，以及当时的余额情况）
* AccountMirror   当前对账流程中，用户的报错情况和余额情况
* BatchRecord     对账批次的情况（日期做为批次作为主键）：是否已审核确认，对账人数，错误情况
* OrderStatus     订单状态，导入时，所有的订单状态都必须转换成这里定义的几种，后面好统计比对和计算金额变化
* Orders          订单主类，主要是增加了导入函数和状态金额比对方法
* Task            对账主类，对账逻辑的实现框架，需要派生，实现诸如导入等等函数
* UserOrderRet    用户对账结果封装类，主要记录处理用户对账结果，需要派生，实现计算金额变化等函数

## 用法

1. 派生4个子类（用于指定库表）：AccountLastOk,AccountMirror,BatchRecord,Orders

2. 派生 UserOrdersRet 的子类
 
    setDBOfOnline() 记住线上数据库链接，用于获取线上用户余额
    chkUserOrders() 调用父类方法后，追加检查用户余额 $this->_balance = array(balance=>计算出的余额， frose=>计算出的冻结金额)
    getAccMirrorByUid()  获取Mirror实例
    getAccLastokByUid()  获取Lastok实例
    chkUserOrders_balanceChg() 根据订单统计结果，计算余额变化

3. 派生Task类

    此处建议分成两个文件，一个类里都是负责导入订单的方法函数，另一个是遵循要求完成导入和检查

    导入数据部分：根据具体情况，调用Order实例的ensureOrder?() 方法 

    step_prepare_batch() 准备好batch的两个实例（当前的批次和最后成功确认的批次）
    step_prepare() 准备好其他实际使用的类的实例（accMirror、accLastOk，Order，ret）
    step_importOrders() 第一轮，按时间为条件，导入订单
    step_recheckUsers() 第二轮，加入用户限制条件，导入订单

4. 扩展

    当出现负载问题时，按用户分服务器处理，一台服务器负责导入和检查一部分用户的数据（一个用户的数据都在一台服务器上，处理下导入部分即可，然后最后的报表统计和审核确认需要注意下，别忘了kvobj支持分表分库）


## 注意事项

1. 这里不锁表，所以第一轮检查后，会把错误的用户再检查一遍，排除对账当时用户正在操作的情况，但只做一次复查，所以存在用户连续踩雷的可能性
2. 设计上，不支持删除订单的情况，请以增加方式补上相关记录后（或手动删除对账系统内订单表的记录），再次运行程序检查
3. 一天最多只有一个检查批次（可以多次执行检查，但批次只有一个），并且一旦确认，当日的不能再查
4. 针对对账的，为简化设计，只有一个订单类型字段，因此使用上订单类型字段取值建议为：购买定期，购买活期；而不要只是购买
5. 因不是所有的系统都能准确记录还原每次对账时的场景，所以设计上，对账以当前状态为准（即当前终态的订单和余额）,这会造成:

* 如果中途有几天没确认，之前的对账批次状态结果几乎就没有意义了
* 某一天确认后，之前的批次，即使记录的状态是未确认，但已经不能再次比对或确认了

6. 没想出好办法应对多系统时间不同步情况（比如对账是03:00:00, 对完帐以后，又有一笔订单记录的时间是02:59:59, 这笔订单次日对账对余额会丢），若有这种情况：

* 要么系统设置暂停服务器时间，停服期间做对账
* 要么系统提供对账镜像数据库
* 要么手动修一下订单库表，再对账